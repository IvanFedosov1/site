## Правила языка Java
Мы следуем стандартным соглашениям по оформлению кода на Java. Мы добавили к ним некоторые правила:  
1.Исключения: никогда не перехватывайте и не игнорируйте их без объяснения.  
2.Исключения: не используйте обобщенные исключения, кроме кода в библиотеках, в корне стека.  
3.Финализаторы: не используйте их.  
4.Импорты: полностью уточняйте импорты.  


## Правила Java библиотек
Существуют соглашения, по поводу использования Java библиотек и инструментов для Android. В некоторых случаях соглашения могут быть изменены, например, в таких как использование старого кода, который, возможно, использует неодобренный паттерн или библиотеку.
## Правила Java стиля

Программы гораздо проще поддерживать, когда все файлы имеют согласованный стиль. Мы следуем стандартному стилю программирования на Java, определенному Sun в их [Code Conventions for the Java Programming Language](https://www.oracle.com/technetwork/java/codeconvtoc-136057.html), с несколькими исключениями и дополнениями. Данное руководство по стилю является подробным и всесторонним, а также широко используется Java сообществом.

В дополнение, мы обязываем использовать следующие правила для кода:
1. Комментарии/Javadoc: пишите их; используйте стандартный стиль.
1. Короткие методы: не пишите гигантских методов.
1. Поля: должны быть вверху файла, или прямо перед методом, который их использует.
1. Локальные переменные: ограничивайте область видимости.
1. Импорты: android; сторонние (в алфавитном порядке); java(x)
1. Отступы: 4 пробела, без табуляций.
1. Длина строки: 100 символов.
1. Имена полей: не public и не static поля начинаются с «m».
1. Фигурные скобки: открывающие фигурные скобки не находятся в отдельной строке.
1. Аннотации: используйте стандартные аннотации.
1. Сокращения: используйте сокращения как слова в именах, например, XmlHttpRequest, getUrl() и т.п.
1. Стиль TODO: «TODO: пишите описание здесь».
1. Согласованность: смотрите, что находится вокруг вас.

## Правила языка Java

### Не игнорируйте исключения

Возможно, вам захочется написать код, который игнорирует исключения, например:

```
void setServerPort(String value) {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) { }
}
```

Никогда так не делайте. В то время как вы думаете, что ваш код никогда не столкнется с таким условием или, что неважно обрабатывать это условие, игнорирование исключений создает скрытые проблемы. Вы в принципе должны обрабатывать каждое исключение. Специфика в каждом конкретном случае зависит от ситуации.  
Приемлимые альтернативы:  
* Перебрасывайте исключения к вызывающему методу.
```
void setServerPort(String value) throws NumberFormatException {
    serverPort = Integer.parseInt(value);
}
```
* Выбрасывайте исключения, соответственно вашему уровню абстракции  
```
void setServerPort(String value) throws ConfigurationException {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) {
        throw new ConfigurationException("Port " + value + " is not valid.");
    }
}
```
* Перехватите ошибку и замените соответствующее значение в блоке catch{}
```
/** Set port. If value is not a valid number, 80 is substituted. */
void setServerPort(String value) {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) {
        serverPort = 80;  // default port for server 
    }
}
```
* Перехватите ошибку и выбросьте RuntimeException. Это опасно: делайте это только если вам все равно случится ли эта ошибка.
```
/** Set port. If value is not a valid number, die. */
void setServerPort(String value) {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) {
        throw new RuntimeException("port " + value " is invalid, ", e);
    }
}
```
Заметьте, что изначальное исключение передается конструктору RuntimeException. Если вы используете компилятор Java 1.3, то опустите исключение.
* Если вы уверены в том, что игнорирование исключения в этом случае имеет место, то хотя бы прокомментируйте, почему вы так решили.
```
/** If value is not a valid number, original port number is used. */
void setServerPort(String value) {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) {
        // Method is documented to just ignore invalid user input.
        // serverPort will just be unchanged.
    }
}
```
#### Не перехватывайте обобщенные исключения
Иногда бывает заманчиво полениться с обработкой исключений и написать что-то вроде этого:  
```
try {
    someComplicatedIOFunction();        // may throw IOException 
    someComplicatedParsingFunction();   // may throw ParsingException 
    someComplicatedSecurityFunction();  // may throw SecurityException 
    // phew, made it all the way 
} catch (Exception e) {               // I'll just catch all exceptions 
    handleError();                      // with one generic handler!
}
```   

Вам не следует так делать. Суть в том, что возможно появление исключения, которого вы не ожидали и, в итоге, ошибка будет отлавливаться на уровне приложения. То есть, если кто-то добавит новый тип исключения, то компилятор не сможет вам помочь понять, что это другая ошибка.

Существуют редкие исключения из этого правила: определенный тестовый код, или код верхнего уровня, где вы хотите перехватывать все типы ошибок (для того, чтобы предотвратить их отображение в пользовательском интерфейсе, или чтобы продолжить какую-то пакетную задачу).

Альтернативы обобщенным исключениям:
* Перехватывайте каждое исключение отдельно в блоке catch, после одиночного try. Возможно это неудобно, но всё равно это предпочтительный способ для перехвата всех исключений.
* Измените ваш код для более гранулированной обработки ошибок с несколькими блоками try. Отделите IO от парсинга, обрабатывайте ошибки отдельно в каждом случае.
* Перебросьте исключение. Во многих случаях вам не нужно обрабатывать все исключения на текущем уровне, просто позвольте методу перебросить их.

Помните: исключения — ваши друзья! Не сердитесь, когда компилятор указывает на то, что вы их не отлавливаете.
#### Финализаторы
**Что это**: Финализаторы — это способ запускать программный код перед тем как объект собирается сборщиком мусора.  
**За**: могут быть полезны при очистке, в особенности внешних ресурсов.  
**Против**: нет никаких гарантий того, когда будет вызван финализатор, и, вообще, будет ли он вызван.
